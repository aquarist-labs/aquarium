from typing import Callable, Dict, List, Optional, Sequence, Tuple, Union

class Version:
    major: int
    minor: int
    extra: int
    def __init__(self, major: int, minor: int, extra: int) -> None: ...

class Error(Exception):
    errno: int

class OSError(Error): ...
class RadosStateError(Error): ...

class OmapIterator:
    def __iter__(self) -> OmapIterator: ...
    def __next__(self) -> Tuple[str, bytes]: ...

class Ioctx:
    def application_enable(self, app_name: str, force: bool = ...) -> None: ...
    def close(self) -> None: ...
    def get_omap_vals(
        self,
        read_op: ReadOp,
        start_after: str,
        filter_prefix: str,
        max_return: int,
    ) -> Tuple[OmapIterator, int]: ...
    def get_omap_vals_by_keys(
        self, read_op: ReadOp, keys: Sequence[str]
    ) -> Tuple[OmapIterator, int]: ...
    def notify(
        self, obj: str, msg: str = ..., timeout_ms: int = ...
    ) -> bool: ...
    def operate_read_op(
        self, read_op: ReadOp, oid: str, flag: int = ...
    ) -> None: ...
    def operate_write_op(
        self,
        write_op: WriteOp,
        oid: str,
        mtime: Optional[int] = ...,
        flags: Optional[int] = ...,
    ) -> None: ...
    def remove_omap_keys(
        self, write_op: WriteOp, keys: Sequence[str]
    ) -> None: ...
    def set_omap(
        self, write_op: WriteOp, keys: Sequence[str], values: Sequence[bytes]
    ) -> None: ...
    def watch(
        self,
        obj: str,
        callback: Callable[[int, str, int, bytes], None],
        error_callback: Optional[Callable[[int], None]] = ...,
        timeout: Optional[int] = ...,
    ) -> Watch: ...
    def write_full(self, key: str, data: bytes) -> int: ...

class ReadOp: ...

class ReadOpCtx(ReadOp):
    def __enter__(self) -> ReadOpCtx: ...
    def __exit__(self, type_, value, tracekback) -> bool: ...

class Watch:
    def get_id(self) -> int: ...
    def close(self) -> None: ...

class WriteOp:
    def assert_version(self, version: int) -> None: ...

class WriteOpCtx(WriteOp):
    def __enter__(self) -> WriteOpCtx: ...
    def __exit__(self, type_, value, tracekback) -> bool: ...

class Rados:
    state: str
    def __init__(
        self,
        rados_id: Optional[str] = ...,
        name: Optional[str] = ...,
        clustername: Optional[str] = ...,
        conf_defaults: Optional[Dict[str, str]] = ...,
        conffile: Union[str, int, None] = ...,
        flags: Optional[int] = ...,
        context: Optional[object] = ...,
    ) -> None: ...
    def get_addrs(self) -> List[str]: ...
    def require_state(self, state: str) -> None: ...
    def shutdown(self) -> None: ...
    def version(self) -> Version: ...
    def conf_read_file(self, path: Optional[str] = ...) -> None: ...
    def conf_parse_argv(self, args: Sequence[str]) -> None: ...
    def conf_parse_env(self, var: Optional[str] = ...) -> None: ...
    def conf_get(self, option: str) -> Optional[str]: ...
    def conf_set(self, option: str, val: str) -> None: ...
    def ping_monitor(self, mon_id: str) -> None: ...
    def connect(self, timeout: Optional[int] = ...) -> None: ...
    def get_instance_id(self) -> int: ...
    def get_cluster_stats(self) -> Dict[str, int]: ...
    def pool_exists(self, pool_name: str) -> bool: ...
    def pool_lookup(self, pool_name: str) -> int: ...
    def pool_reverse_lookup(self, pool_id: int) -> str: ...
    def create_pool(
        self,
        pool_name: str,
        crush_rule: Optional[int] = ...,
        auid: Optional[int] = ...,
    ) -> None: ...
    def get_pool_base_tier(self, pool_id: int) -> int: ...
    def delete_pool(self, pool_name: str) -> None: ...
    def get_inconsistent_pgs(self, pool_id: int) -> List[str]: ...
    def list_pools(self) -> List[str]: ...
    def get_fsid(self) -> str: ...
    def open_ioctx(self, ioctx_name: str) -> Ioctx: ...
    def open_ioctx2(self, pool_id: int) -> Ioctx: ...
    def mon_command(
        self,
        cmd: str,
        inbuf: bytes,
        timeout: int = ...,
        target: Optional[Union[str, int]] = ...,
    ) -> Tuple[int, bytes, str]: ...
    def osd_command(
        self, osdid: int, cmd: str, inbuf: bytes, timeout: int = ...
    ) -> Tuple[int, bytes, str]: ...
    def mgr_command(
        self,
        cmd: str,
        inbuf: bytes,
        timeout: int = ...,
        target: Optional[str] = ...,
    ) -> Tuple[int, bytes, str]: ...
    def pg_command(
        self, pgid: str, cmd: str, inbuf: bytes, timeout: int = ...
    ) -> Tuple[int, bytes, str]: ...
    def wait_for_latest_osdmap(self) -> int: ...
    def blocklist_add(
        self, client_address: str, expire_seconds: int = ...
    ) -> None: ...
    def monitor_log(
        self,
        level: str,
        callback: Optional[
            Callable[[object, str, str, str, int, int, int, str, str], None]
        ] = ...,
        arg: Optional[object] = ...,
    ) -> None: ...
    def monitor_log2(
        self,
        level: str,
        callback: Optional[
            Callable[
                [object, str, str, str, str, int, int, int, str, str], None
            ]
        ],
        arg: Optional[object] = ...,
    ) -> None: ...
